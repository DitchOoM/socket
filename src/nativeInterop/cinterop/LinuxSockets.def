language = C
package = com.ditchoom.socket.linux

headers = sys/socket.h sys/types.h netinet/in.h netinet/tcp.h arpa/inet.h netdb.h unistd.h fcntl.h errno.h sys/select.h sys/time.h sys/eventfd.h poll.h string.h openssl/ssl.h openssl/err.h openssl/x509.h liburing.h

compilerOpts.linux = -D_GNU_SOURCE -D_POSIX_C_SOURCE=200809L -I/usr/include -I/usr/include/x86_64-linux-gnu
linkerOpts.linux = -L/usr/lib/x86_64-linux-gnu -luring -lssl -lcrypto -lpthread

---

// Wrapper functions to work around glibc __SOCKADDR_ARG union type issues
// These take raw struct sockaddr* pointers which Kotlin/Native can handle

static inline int socket_getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen) {
    return getsockname(sockfd, addr, addrlen);
}

static inline int socket_getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen) {
    return getpeername(sockfd, addr, addrlen);
}

static inline int socket_bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen) {
    return bind(sockfd, addr, addrlen);
}

static inline int socket_accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen) {
    return accept(sockfd, addr, addrlen);
}

// Wrapper for SSL_set_tlsext_host_name macro (not available via cinterop)
static inline long ssl_set_hostname(SSL *ssl, const char *hostname) {
    return SSL_set_tlsext_host_name(ssl, hostname);
}
