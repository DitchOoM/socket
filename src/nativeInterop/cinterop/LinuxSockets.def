language = C
package = com.ditchoom.socket.linux

# Linux socket implementation with io_uring async I/O and OpenSSL TLS support.
#
# Dependencies:
#   - liburing: System package (sudo apt install liburing-dev)
#   - OpenSSL: Pre-built static libraries in libs/openssl/linux-x64/
#              Built on CentOS 7 (glibc 2.17) for K/N compatibility
#              To rebuild: ./buildSrc/openssl/build-openssl.sh
#
# Why static OpenSSL? Kotlin/Native bundles glibc 2.19, but Ubuntu 24.04's
# dynamic libssl requires glibc 2.33+. Our static build uses glibc 2.17.

headers = sys/socket.h sys/types.h netinet/in.h netinet/tcp.h arpa/inet.h netdb.h unistd.h fcntl.h errno.h sys/select.h sys/time.h sys/eventfd.h poll.h string.h liburing.h openssl/ssl.h openssl/err.h openssl/x509.h

# Compiler flags - include paths are set via build.gradle.kts includeDirs
# to support both native compilation and cross-compilation
compilerOpts.linux = -D_GNU_SOURCE -D_POSIX_C_SOURCE=200809L

# Linker flags - library paths are set in build.gradle.kts
linkerOpts.linux = -lpthread -ldl

---

// Wrapper functions to work around glibc __SOCKADDR_ARG union type issues
// These take raw struct sockaddr* pointers which Kotlin/Native can handle

static inline int socket_getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen) {
    return getsockname(sockfd, addr, addrlen);
}

static inline int socket_getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen) {
    return getpeername(sockfd, addr, addrlen);
}

static inline int socket_bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen) {
    return bind(sockfd, addr, addrlen);
}

static inline int socket_accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen) {
    return accept(sockfd, addr, addrlen);
}

// OpenSSL wrapper for setting SNI hostname (SSL_set_tlsext_host_name is a macro)
static inline int ssl_set_hostname(SSL *ssl, const char *hostname) {
    return SSL_set_tlsext_host_name(ssl, hostname);
}
