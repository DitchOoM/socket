language = C
package = com.ditchoom.socket.linux

# Linux socket implementation with io_uring async I/O and OpenSSL TLS support.
# Uses static linking for OpenSSL to avoid glibc version incompatibility.
# Kotlin/Native uses glibc 2.19, but Ubuntu 24.04's dynamic libssl requires glibc 2.33+.
headers = sys/socket.h sys/types.h netinet/in.h netinet/tcp.h arpa/inet.h netdb.h unistd.h fcntl.h errno.h sys/select.h sys/time.h sys/eventfd.h poll.h string.h liburing.h openssl/ssl.h openssl/err.h openssl/x509.h

# Use system headers for cinterop generation (requires liburing-dev, libssl-dev packages)
# The --sysroot override allows cinterop to find system headers
compilerOpts.linux = -D_GNU_SOURCE -D_POSIX_C_SOURCE=200809L \
    -I/usr/include \
    -I/usr/include/x86_64-linux-gnu \
    -I/usr/include/openssl

linkerOpts.linux = -L/usr/lib/x86_64-linux-gnu -luring -lssl -lcrypto -lpthread -ldl

---

// Wrapper functions to work around glibc __SOCKADDR_ARG union type issues
// These take raw struct sockaddr* pointers which Kotlin/Native can handle

static inline int socket_getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen) {
    return getsockname(sockfd, addr, addrlen);
}

static inline int socket_getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen) {
    return getpeername(sockfd, addr, addrlen);
}

static inline int socket_bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen) {
    return bind(sockfd, addr, addrlen);
}

static inline int socket_accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen) {
    return accept(sockfd, addr, addrlen);
}

// OpenSSL wrapper for setting SNI hostname (SSL_set_tlsext_host_name is a macro)
static inline int ssl_set_hostname(SSL *ssl, const char *hostname) {
    return SSL_set_tlsext_host_name(ssl, hostname);
}
